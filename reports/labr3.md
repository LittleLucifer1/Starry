### 编程实验

#### 实验3.1

​	修改完`DSCARD_TESTCASES`之后，首先尝试运行程序，发现提示报`permission deny`的错误。此时还是对整个过程一脸蒙，于是，打开本机的`strace`查看参考答案。在参考答案和错误的系统调用中，发现出问题的地方是在`fstatat`之后。在错误中，此函数的返回值为`-64`，寻找这个报错的位置，最终发现是在`mount.rs`中，而参考答案的返回值为-1，此时结合注释，我猜测这个`ENONET`应该不是预期的报错信息。于是我进入`LinuxError`中寻找我想要的报错信息（还没意识到此时犯的错误），找了两个我认为合适的，加入进去，结果不对。于是，又苦苦挣扎了一段时间，猛然发现，参考答案中的给了我需要的报错信息，就是`ENOENT`。这个和错误的`ENONET`也太像了吧。

​	跑了之后发现错误变了，需要我修改`syscall_renameat2`函数。查询文档，了解了基本的用法，根据提示中给出的函数，稍微完善了一下功能，不过不完备（懒），但是可以输出正常的结果了。函数中有些变量也是让人摸不着头脑，于是，使用了`error()`输出大法，才知道这个`old_path.path()`究竟是什么。

（为了方便，我两次的文件名都是`def`）

![](/reports/1.png)

#### 实验3.2

​	修改完`DSCARD_TESTCASES`之后，首先尝试运行程序，发现有错误。借助于上个实验中，我在相关函数中加入的`error`信息，原来是程序将`bin`识别为文件了，在上个实验中，`new_path.path() = /bin/abc`，而这个实验中，`new_path.path() = \bin`。猜测，应该是识别文件和目录的相关代码有些问题。于是，在相关的函数中，找来找去，最终发现，这个`mount.rs`中判断目录的判断语句情况不完全，应该使用`metadata()`去判断。所以就修改了一下这一行，最后有了正确的结果。（还是得理清线索）

![](/reports/2.png)

**思考题1.1**：这些代码具体在 `~/.cargo` 下的哪个文件夹？

通过跳转，发现在`~/.cargo/registry/src`中。首先这个`~/.cargo`文件夹是在用户的主目录下，应该是存放与Cargo相关的配置文件和缓存数据。其中的`registry`文件夹用于存储在`crates.io`中下载和缓存所需要的依赖项。

**思考题1.2**：如果忘记 `make clean` 会发生什么？

在这里的操作中，尝试忘记`make clean`和先`make clean`，再`make run`结果一样。应该是因为修改了依赖库后，这个文件被修改过了，`makefile`会重新编译这个库文件。但是在后续的操作中，应该还是需要`make clean`.例如，在修改`sdcard`中，如果不使用这个编译命令，原`disk.img`中还是包括之前的测例，而不是最新的测例。

**思考题2**：在*部分往届内核及运行指引*一节提到的内核中挑选一个，描述它在默认情况下启动后会执行哪些测例（抑或是直接启动终端）。你不一定要真的运行那个内核，读文档或搜索即可。

我选择了`ByteOs`，直接全局搜索`lmbench`，最终应该找到了运行测例的地方。

![](/reports/3.png)

**思考题3.1**：为什么要在开头结尾各输出一句，会不会太过重复？（提示：考虑执行出错的情况，或者 `sys_exit` ）

在还没有看到这个问题的时候就有这个疑惑了。对比了两种（开头结尾各有和只有开头）的输出结果，发现`id=94`的系统调用都只执行了一次，而且是最后一次。在之后的操作中，才明白了结尾的`error`会返回上一个`syscall`的返回值，不是标准的一个`syscall`之后会有一个返回值的信息。所以正是因为开头结尾各有一个，才能观察`syscall`的行为。

**思考题3.2**：为什么要结尾还要输出一遍 `syscall` 的完整参数，只输出返回值行不行？（提示：考虑像 `sys_yield` 这样的 `syscall`）

（回答这个问题的时候，我还没去上课。之后发现课上讲了。）当时是猜测可以提供调用`syscall`的进程信息，然后就没有然后了......
